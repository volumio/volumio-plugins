// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   ../alcalzone-shared/types
//   ../events
//   ../node-coap-client

import { Overwrite as Merge } from "alcalzone-shared/types";
import { EventEmitter } from "events";
import { CoapResponse, RequestMethod } from "node-coap-client";

export enum AccessoryTypes {
        /** A "normal" remote */
        remote = 0,
        /**
            * A remote which has been paired with another remote.
            * See https://www.reddit.com/r/tradfri/comments/6x1miq for details
            */
        slaveRemote = 1,
        /** A lightbulb */
        lightbulb = 2,
        /** A smart plug */
        plug = 3,
        /** A motion sensor (currently unsupported) */
        motionSensor = 4,
        /** A signal repeater */
        signalRepeater = 6,
        /** A smart blind */
        blind = 7
}
export class Accessory extends IPSODevice {
        type: AccessoryTypes;
        deviceInfo: DeviceInfo;
        alive: boolean;
        lastSeen: number;
        lightList: Light[];
        plugList: Plug[];
        sensorList: Sensor[];
        switchList: IPSODevice[];
        repeaterList: IPSODevice[];
        blindList: Blind[];
        otaUpdateState: number;
        /**
            * Fixes property values that are known to be bugged
            */
        fixBuggedProperties(): this;
}

export enum PowerSources {
    Unknown = 0,
    InternalBattery = 1,
    ExternalBattery = 2,
    Battery = 3,
    PowerOverEthernet = 4,
    USB = 5,
    AC_Power = 6,
    Solar = 7
}
export class DeviceInfo extends IPSOObject {
    battery: number;
    firmwareVersion: string;
    manufacturer: string;
    modelNumber: string;
    power: PowerSources;
    serialNumber: string;
}

/** contains information about the gateway */
export class GatewayDetails extends IPSOObject {
    alexaPairStatus: boolean;
    googleHomePairStatus: boolean;
    certificateProvisioned: boolean;
    commissioningMode: number;
    utcNowUnixTimestamp: number;
    utcNowISODate: string;
    timeSource: number;
    ntpServerUrl: string;
    version: string;
    UNKNOWN_9062: number;
    otaUpdateState: boolean;
    updateProgress: number;
    updatePriority: UpdatePriority;
    updateAcceptedTimestamp: number;
    releaseNotes: string;
    dstStartMonth: number;
    dstStartDay: number;
    dstStartHour: number;
    dstStartMinute: number;
    dstEndMonth: number;
    dstEndDay: number;
    dstEndHour: number;
    dstEndMinute: number;
    dstTimeOffset: number;
    UNKNOWN_9081: string;
    UNKNOWN_9082: boolean;
    UNKNOWN_9083: string;
    UNKNOWN_9092: number;
    UNKNOWN_9106: number;
    forceOtaUpdateCheck: string;
    name: string;
}
export enum UpdatePriority {
    Normal = 0,
    Critical = 1,
    Required = 2,
    Forced = 5
}

export interface GroupInfo {
        group: Group;
        scenes: Record<string, Scene>;
}
export class Group extends IPSODevice {
        onOff: boolean;
        dimmer: number;
        sceneId: number;
        deviceIDs: number[];
        transitionTime: number;
        /** Turn all lightbulbs on */
        turnOn(): Promise<boolean>;
        /** Turn all lightbulbs off */
        turnOff(): Promise<boolean>;
        /** Set all lightbulbs on/off to the given state */
        toggle(value: boolean): Promise<boolean>;
        /** Activates the given scene */
        activateScene(sceneOrId: Scene | number): Promise<boolean>;
        /**
            * Changes this lightbulb's brightness
            * @returns true if a request was sent, false otherwise
            */
        setBrightness(value: number, transitionTime?: number): Promise<boolean>;
}
export type GroupOperation = Partial<Pick<Group, "onOff" | "dimmer" | "sceneId" | "transitionTime">>;

export class IPSODevice extends IPSOObject {
    name: string;
    createdAt: number;
    instanceId: number;
}

export type LightOperation = Partial<Pick<Light, "onOff" | "dimmer" | "color" | "colorTemperature" | "colorX" | "colorY" | "hue" | "saturation" | "transitionTime">>;
export class Light extends IPSODevice {
        constructor(options?: IPSOOptions, accessory?: Accessory);
        color: string;
        hue: number;
        saturation: number;
        colorX: number;
        colorY: number;
        colorTemperature: number;
        transitionTime: number;
        cumulativeActivePower: number;
        dimmer: number;
        onOff: boolean;
        onTime: number;
        powerFactor: number;
        unit: string;
        /**
            * Returns true if the current lightbulb is dimmable
            */
        readonly isDimmable: boolean;
        /**
            * Returns true if the current lightbulb is switchable
            */
        readonly isSwitchable: boolean;
        clone(): this;
        readonly spectrum: Spectrum;
        /**
            * Creates a proxy which redirects the properties to the correct internal one
            */
        createProxy(): this;
        /** Turn this lightbulb on */
        turnOn(): Promise<boolean>;
        /** Turn this lightbulb off */
        turnOff(): Promise<boolean>;
        /** Toggles this lightbulb on or off */
        toggle(value?: boolean): Promise<boolean>;
        /**
            * Changes this lightbulb's brightness
            * @returns true if a request was sent, false otherwise
            */
        setBrightness(value: number, transitionTime?: number): Promise<boolean>;
        /**
            * Changes this lightbulb's color
            * @param value The target color as a 6-digit hex string
            * @returns true if a request was sent, false otherwise
            */
        setColor(value: string, transitionTime?: number): Promise<boolean>;
        /**
            * Changes this lightbulb's color temperature
            * @param value The target color temperature in the range 0% (cold) to 100% (warm)
            * @returns true if a request was sent, false otherwise
            */
        setColorTemperature(value: number, transitionTime?: number): Promise<boolean>;
        /**
            * Changes this lightbulb's color hue
            * @returns true if a request was sent, false otherwise
            */
        setHue(value: number, transitionTime?: number): Promise<boolean>;
        /**
            * Changes this lightbulb's color saturation
            * @returns true if a request was sent, false otherwise
            */
        setSaturation(value: number, transitionTime?: number): Promise<boolean>;
        /** Turns this object into JSON while leaving out the potential circular reference */
        toJSON(): {};
        /**
            * Fixes property values that are known to be bugged
            */
        fixBuggedProperties(): this;
}
export type Spectrum = "none" | "white" | "rgb";

export class LightSetting extends IPSODevice {
    color: string;
    hue: number;
    saturation: number;
    colorX: number;
    colorY: number;
    colorTemperature: number;
    dimmer: number;
    onOff: boolean;
}

export class Notification extends IPSOObject {
    timestamp: number;
    event: NotificationTypes;
    readonly details: NotificationDetails;
    isActive: boolean;
    toJSON(): {
        timestamp: number;
        event: string;
        details: NotificationDetails;
        isActive: boolean;
    };
}
export class RebootNotification extends IPSOObject {
    reason: GatewayRebootReason;
    toJSON(): {
        reason: string;
    };
}
export class FirmwareUpdateNotification extends IPSOObject {
    releaseNotes: string;
    priority: UpdatePriority;
    toJSON(): {
        releaseNotes: string;
        priority: string;
    };
}
export type NotificationDetails = RebootNotification | FirmwareUpdateNotification | Record<string, string>;
export enum NotificationTypes {
    NewFirmwareAvailable = 1001,
    Reboot = 1003,
    UNKNOWN1 = 1004,
    UNKNOWN2 = 1005,
    LossOfInternetConnectivity = 5001
}
export enum GatewayRebootReason {
    "default" = -1,
    "firmware upgrade" = 0,
    "initiated by client" = 1,
    "homekit reset" = 3,
    "factory reset" = 2
}

export type PlugOperation = Partial<Pick<Plug, "onOff" | "dimmer">>;
export class Plug extends IPSODevice {
        constructor(options?: IPSOOptions, accessory?: Accessory);
        cumulativeActivePower: number;
        dimmer: number;
        onOff: boolean;
        onTime: number;
        powerFactor: number;
        /**
            * Returns true if the current plug is dimmable
            */
        readonly isDimmable: boolean;
        /**
            * Returns true if the current plug is switchable
            */
        readonly isSwitchable: boolean;
        clone(): this;
        /**
            * Creates a proxy which redirects the properties to the correct internal one, does nothing now
            */
        createProxy(): this;
        /** Turn this plug on */
        turnOn(): Promise<boolean>;
        /** Turn this plug off */
        turnOff(): Promise<boolean>;
        /** Toggles this plug on or off */
        toggle(value?: boolean): Promise<boolean>;
        /**
            * Changes this plug's "brightness". Any value > 0 turns the plug on, 0 turns it off.
            * @returns true if a request was sent, false otherwise
            */
        setBrightness(value: number): Promise<boolean>;
        /** Turns this object into JSON while leaving out the potential circular reference */
        toJSON(): {};
}

export class Scene extends IPSODevice {
    isActive: boolean;
    isPredefined: boolean;
    lightSettings: LightSetting[];
    blindSettings: BlindSetting[];
    sceneIndex: number;
    useCurrentLightSettings: boolean;
}

export class Sensor extends IPSODevice {
    appType: string;
    sensorType: string;
    minMeasuredValue: number;
    maxMeasuredValue: number;
    minRangeValue: number;
    maxRangeValue: number;
    resetMinMaxMeasureValue: boolean;
    sensorValue: number;
    unit: string;
}

export enum TradfriErrorCodes {
    ConnectionFailed = 0,
    ConnectionTimedOut = 1,
    AuthenticationFailed = 2,
    NetworkReset = 3
}
export class TradfriError extends Error {
    readonly message: string;
    readonly code: TradfriErrorCodes;
    constructor(message: string, code: TradfriErrorCodes);
}

export interface DiscoveredGateway {
    name: string;
    host?: string;
    version: string;
    addresses: string[];
}
/**
  * Auto-discover a tradfri gateway on the network.
  * @param timeout (optional) Time in milliseconds to wait for a response. Default 10000.
  * Pass false or a negative number to explicitly wait forever.
  */
export function discoverGateway(timeout?: number | false): Promise<DiscoveredGateway | null>;

export type ConnectionFailedCallback = (attempt: number, maxAttempts: number) => void;
export interface ConnectionEventCallbacks {
    "connection failed": ConnectionFailedCallback;
}
export type ConnectionEvents = keyof ConnectionEventCallbacks;
export type ConnectionWatcherEvents = "ping succeeded" | "ping failed" | "connection alive" | "connection lost" | "gateway offline" | "reconnecting" | "give up";
export type PingFailedCallback = (failedPingCount: number) => void;
export type ReconnectingCallback = (reconnectAttempt: number, maximumReconnects: number) => void;
export type ConnectionWatcherEventCallbacks = Merge<{
    [K in ConnectionWatcherEvents]: () => void;
}, {
    "ping failed": PingFailedCallback;
    "reconnecting": ReconnectingCallback;
}>;
export type DeviceUpdatedCallback = (device: Accessory) => void;
export type DeviceRemovedCallback = (instanceId: number) => void;
export type GroupUpdatedCallback = (group: Group) => void;
export type GroupRemovedCallback = (instanceId: number) => void;
export type SceneUpdatedCallback = (groupId: number, scene: Scene) => void;
export type SceneRemovedCallback = (groupId: number, instanceId: number) => void;
export type ErrorCallback = (e: Error) => void;
export type GatewayUpdatedCallback = (gateway: GatewayDetails) => void;
export interface ObservableEventCallbacks {
    "device updated": DeviceUpdatedCallback;
    "device removed": DeviceRemovedCallback;
    "group updated": GroupUpdatedCallback;
    "group removed": GroupRemovedCallback;
    "scene updated": SceneUpdatedCallback;
    "scene removed": SceneRemovedCallback;
    "gateway updated": GatewayUpdatedCallback;
    "error": ErrorCallback;
}
export type ObservableEvents = keyof ObservableEventCallbacks;
export type RebootNotificationCallback = (reason: keyof typeof GatewayRebootReason) => void;
export type FirmwareUpdateNotificationCallback = (releaseNotes: string, priority: keyof typeof UpdatePriority) => void;
export type InternetConnectivityChangedCallback = (connected: boolean) => void;
export interface NotificationEventCallbacks {
    "rebooting": RebootNotificationCallback;
    "internet connectivity changed": FirmwareUpdateNotificationCallback;
    "firmware update available": InternetConnectivityChangedCallback;
}
export type NotificationEvents = keyof NotificationEventCallbacks;
export type AllEventCallbacks = Merge<Merge<ObservableEventCallbacks, NotificationEventCallbacks>, Merge<ConnectionWatcherEventCallbacks, ConnectionEventCallbacks>>;
export type AllEvents = keyof AllEventCallbacks;

export type ObserveResourceCallback = (resp: CoapResponse) => void;
export type ObserveDevicesCallback = (addedDevices: Accessory[], removedDevices: Accessory[]) => void;
export interface TradfriClient {
        on<TEvent extends AllEvents>(event: TEvent, callback: AllEventCallbacks[TEvent]): this;
        removeListener<TEvent extends AllEvents>(event: TEvent, callback: AllEventCallbacks[TEvent]): this;
        removeAllListeners(event?: AllEvents): this;
}
export interface TradfriOptions {
        /** Callback for a custom logger function. */
        customLogger: LoggerFunction;
        /** Whether to use raw CoAP values or the simplified scale */
        useRawCoAPValues: boolean;
        /** Whether the connection should be automatically watched */
        watchConnection: boolean | Partial<ConnectionWatcherOptions>;
}
export class TradfriClient extends EventEmitter implements OperationProvider {
        readonly hostname: string;
        /** dictionary of CoAP observers */
        observedPaths: string[];
        /** dictionary of known devices */
        devices: Record<string, Accessory>;
        /** dictionary of known groups */
        groups: Record<string, GroupInfo>;
        constructor(hostname: string);
        constructor(hostname: string, customLogger: LoggerFunction);
        constructor(hostname: string, options: Partial<TradfriOptions>);
        /**
            * Connect to the gateway
            * @param identity A previously negotiated identity.
            * @param psk The pre-shared key belonging to the identity.
            */
        connect(identity: string, psk: string): Promise<true>;
        /**
            * Negotiates a new identity and psk with the gateway to use for connections
            * @param securityCode The security code that is printed on the gateway
            * @returns The identity and psk to use for future connections. Store these!
            * @throws TradfriError
            */
        authenticate(securityCode: string): Promise<{
                identity: string;
                psk: string;
        }>;
        /**
            * Observes a resource at the given url and calls the callback when the information is updated.
            * Prefer the specialized versions if possible.
            * @param path The path of the resource
            * @param callback The callback to be invoked when the resource updates
            * @returns true if the observer was set up, false otherwise (e.g. if it already exists)
            */
        observeResource(path: string, callback: (resp: CoapResponse) => void): Promise<boolean>;
        /**
            * Checks if a resource is currently being observed
            * @param path The path of the resource
            */
        isObserving(path: string): boolean;
        /**
            * Stops observing a resource that is being observed through `observeResource`
            * Use the specialized version of this method for observers that were set up with the specialized versions of `observeResource`
            * @param path The path of the resource
            */
        stopObservingResource(path: string): void;
        /**
            * Resets the underlying CoAP client and clears all observers.
            * @param preserveObservers Whether the active observers should be remembered to restore them later
            */
        reset(preserveObservers?: boolean): void;
        /**
            * Closes the underlying CoAP client and clears all observers.
            */
        destroy(): void;
        /**
            * Restores all previously remembered observers with their original callbacks
            * Call this AFTER a dead connection was restored
            */
        restoreObservers(): Promise<void>;
        /**
            * Sets up an observer for all devices
            * @returns A promise that resolves when the information about all devices has been received.
            */
        observeDevices(): Promise<void>;
        stopObservingDevices(): void;
        /**
            * Sets up an observer for all groups and scenes
            * @returns A promise that resolves when the information about all groups and scenes has been received.
            */
        observeGroupsAndScenes(): Promise<void>;
        stopObservingGroups(): void;
        /**
            * Sets up an observer for the gateway
            * @returns A promise that resolves when the gateway information has been received for the first time
            */
        observeGateway(): Promise<void>;
        stopObservingGateway(): void;
        /**
            * Sets up an observer for the notification
            * @returns A promise that resolves when a notification has been received for the first time
            */
        observeNotifications(): Promise<void>;
        stopObservingNotifications(): void;
        /**
            * Pings the gateway to check if it is alive
            * @param timeout - (optional) Timeout in ms, after which the ping is deemed unanswered. Default: 5000ms
            */
        ping(timeout?: number): Promise<boolean>;
        /**
            * Updates a device object on the gateway
            * @param accessory The device to be changed
            * @returns true if a request was sent, false otherwise
            */
        updateDevice(accessory: Accessory): Promise<boolean>;
        /**
            * Updates a group object on the gateway
            * @param group The group to be changed
            * @returns true if a request was sent, false otherwise
            */
        updateGroup(group: Group): Promise<boolean>;
        /**
            * Sets some properties on a group
            * @param group The group to be updated
            * @param operation The properties to be set
            * @param force If the provided properties must be sent in any case
            * @returns true if a request was sent, false otherwise
            */
        operateGroup(group: Group, operation: GroupOperation, force?: boolean): Promise<boolean>;
        /**
            * Sets some properties on a lightbulb
            * @param accessory The parent accessory of the lightbulb
            * @param operation The properties to be set
            * @returns true if a request was sent, false otherwise
            */
        operateLight(accessory: Accessory, operation: LightOperation): Promise<boolean>;
        /**
            * Sets some properties on a plug
            * @param accessory The parent accessory of the plug
            * @param operation The properties to be set
            * @returns true if a request was sent, false otherwise
            */
        operatePlug(accessory: Accessory, operation: PlugOperation): Promise<boolean>;
        /**
            * Sets some properties on a blind
            * @param accessory The parent accessory of the blind
            * @param operation The properties to be set
            * @returns true if a request was sent, false otherwise
            */
        operateBlind(accessory: Accessory, operation: BlindOperation): Promise<boolean>;
        /**
            * Sends a custom request to a resource
            * @param path The path of the resource
            * @param method The method of the request
            * @param payload The optional payload as a JSON object
            */
        request(path: string, method: RequestMethod, payload?: object): Promise<{
                code: string;
                payload: any;
        }>;
        /** Reboots the gateway. This operation is additionally acknowledged with a reboot notification. */
        rebootGateway(): Promise<boolean>;
        /** Factory resets the gateway. WARNING: All configuration will be wiped! */
        resetGateway(): Promise<boolean>;
}

export type BlindOperation = Partial<Pick<Blind, "position">>;
export class Blind extends IPSODevice {
        constructor(options?: IPSOOptions, accessory?: Accessory);
        position: number;
        /**
            * Returns true if the current blind is dimmable
            */
        readonly isDimmable: boolean;
        /**
            * Returns true if the current blind is switchable
            */
        readonly isSwitchable: boolean;
        clone(): this;
        /**
            * Creates a proxy which redirects the properties to the correct internal one, does nothing now
            */
        createProxy(): this;
        /** Open these blinds */
        open(): Promise<boolean>;
        /** Close these blinds */
        close(): Promise<boolean>;
        /**
            * Changes this plug's "brightness". Any value > 0 turns the plug on, 0 turns it off.
            * @returns true if a request was sent, false otherwise
            */
        setPosition(value: number): Promise<boolean>;
        /** Turns this object into JSON while leaving out the potential circular reference */
        toJSON(): {};
}

export type PropertyTransformKernel = (value: any, parent?: IPSOObject) => any;
export interface PropertyTransform extends PropertyTransformKernel {
        /** If this transform is not supposed to be skipped ever */
        neverSkip: boolean;
        /** If this transform requires arrays to be split */
        splitArrays: boolean;
}
export type RequiredPredicate = (me: IPSOObject, reference?: IPSOObject) => boolean;
/**
    * Defines the ipso key neccessary to serialize a property to a CoAP object
    */
export const ipsoKey: (key: string) => PropertyDecorator;
/**
    * Declares that a property is required to be present in a serialized CoAP object
    */
export const required: (predicate?: boolean | RequiredPredicate) => PropertyDecorator;
/**
    * Defines the required transformations to serialize a property to a CoAP object
    * @param kernel The transformation to apply during serialization
    * @param options Some options regarding the behavior of the property transform
    */
export function serializeWith(kernel: PropertyTransformKernel, options?: {
        splitArrays?: boolean;
        neverSkip?: boolean;
}): PropertyDecorator;
/**
    * Defines the required transformations to deserialize a property from a CoAP object
    * @param kernel The transformation to apply during deserialization
    * @param options Options for deserialisation
    */
export function deserializeWith(kernel: PropertyTransformKernel, options?: {
        splitArrays?: boolean;
        neverSkip?: boolean;
}): PropertyDecorator;
/**
    * Defines that a property will not be serialized
    */
export const doNotSerialize: <T extends IPSOObject>(target: T, property: string | keyof T) => void;
/**
    * Provides a set of options regarding IPSO objects and serialization
    */
export interface IPSOOptions {
        /**
            * Determines if basic serializers (i.e. for simple values) should be skipped
            * This is used to support raw CoAP values instead of the simplified scales
            */
        skipValueSerializers?: boolean;
}
export class IPSOObject {
        constructor(options?: IPSOOptions);
        /**
            * Reads this instance's properties from the given object
            */
        parse(obj: Record<string, any>): this;
        /**
            * Overrides this object's properties with those from another partial one
            */
        merge(obj: Partial<this>, allProperties?: boolean): this;
        /** serializes this object in order to transfer it via COAP */
        serialize(reference?: this): Record<string, any>;
        /**
            * Deeply clones an IPSO Object
            */
        clone(...constructorArgs: any[]): this;
        /** If this object was proxied or not */
        readonly isProxy: boolean;
        /** Returns the raw object without a wrapping proxy */
        unproxy(): this;
        /**
            * Creates a proxy for this device
            * @param get Custom getter trap (optional). This is called after mandatory traps are in place and before default behavior
            * @param set Custom setter trap (optional). This is called after mandatory traps are in place and before default behavior
            */
        createProxy(get?: (me: this, key: PropertyKey) => any, set?: (me: this, key: PropertyKey, value: any, receiver: any) => boolean): this;
        protected client: OperationProvider | undefined;
        /**
            * Fixes property values that are known to be bugged
            */
        fixBuggedProperties(): this;
}

export class BlindSetting extends IPSODevice {
    position: number;
}

export type LoggerFunction = (message: string, severity?: "info" | "warn" | "debug" | "error" | "silly") => void;
export function setCustomLogger(logger: LoggerFunction): void;
export function log(message: string, severity?: "info" | "warn" | "debug" | "error" | "silly"): void;

export interface OperationProvider {
    operateGroup(group: Group, operation: GroupOperation, force?: boolean): Promise<boolean>;
    operateLight(accessory: Accessory, operation: LightOperation): Promise<boolean>;
    operatePlug(accessory: Accessory, operation: PlugOperation): Promise<boolean>;
    operateBlind(accessory: Accessory, operation: BlindOperation): Promise<boolean>;
}

/** Configures options for connection watching and automatic reconnection */
export interface ConnectionWatcherOptions {
        /** The interval in ms between consecutive pings */
        pingInterval: number;
        /** How many pings have to consecutively fail until the gateway is assumed offline */
        failedPingCountUntilOffline: number;
        /**
            * How much the interval between consecutive pings should be increased while the gateway is offline.
            * The actual interval is calculated by <ping interval> * <backoff factor> ** <min(5, # offline pings)>
            */
        failedPingBackoffFactor: number;
        /** Whether automatic reconnection is enabled */
        reconnectionEnabled: boolean;
        /** How many pings have to consecutively fail while the gateway is offline until a reconnection is triggered */
        offlinePingCountUntilReconnect: number;
        /** After how many failed reconnects we give up. Number.POSITIVE_INFINITY to never gonna give you up, never gonna let you down... */
        maximumReconnects: number;
        /** How many tries for the initial connection should be attempted */
        maximumConnectionAttempts: number;
        /** The interval in ms between consecutive connection attempts */
        connectionInterval: number;
        /**
            * How much the interval between consecutive connection attempts should be increased.
            * The actual interval is calculated by <connection interval> * <backoff factor> ** <min(5, # failed attempts)>
            */
        failedConnectionBackoffFactor: number;
}
export interface ConnectionWatcher {
        on<TEvent extends ConnectionWatcherEvents>(event: TEvent, callback: ConnectionWatcherEventCallbacks[TEvent]): this;
        removeListener<TEvent extends ConnectionWatcherEvents>(event: TEvent, callback: ConnectionWatcherEventCallbacks[TEvent]): this;
        removeAllListeners(event?: ConnectionWatcherEvents): this;
}
/**
    * Watches the connection of a TradfriClient and notifies about changes in the connection state
    */
export class ConnectionWatcher extends EventEmitter {
        constructor(client: TradfriClient, options?: Partial<ConnectionWatcherOptions>);
        readonly options: ConnectionWatcherOptions;
        /** Starts watching the connection */
        start(): void;
        /** Stops watching the connection */
        stop(): void;
}

